# 单元测试相关知识点

单元测试是软件开发中的一种关键测试方法，专注于验证代码中最小的可测试单元（通常是函数、方法或类）是否按预期工作。其核心目的是在早期隔离并检测代码中的逻辑错误、边界条件问题和接口缺陷，确保每个独立组件的正确性。通过自动化测试框架（如Google Test、JUnit等），开发者可以快速运行大量测试用例，覆盖正常输入、异常输入和边缘情况，从而在代码修改后立即验证功能是否被破坏。单元测试不仅提升了代码质量，还促进了模块化设计（因为可测试的代码往往耦合度更低），并为后续的集成测试和系统测试奠定基础。它是持续集成（CI）流程的重要组成部分，能够在代码合并前自动拦截问题，减少后期修复成本。

## 单元测试

### 单元测试创建

1. **VualStudio:新建项目——> 搜索test——> 本机单元测试**

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9E%84%E5%BB%BA01.png)

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9E%84%E5%BB%BA02.png)

2. 在单元测试项目中，右键单击“引用”或“依赖项”，然后选择“添加引用”或“添加项目引用”，添加对要测试的项目的引用 。

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%BC%95%E7%94%A8%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE.png)

3. 向单元测试方法添加代码。例如，你可以通过选择与测试框架匹配的正确文档选项卡来使用以下代码：MSTest、NUnit 或 xUnit（仅在 .NET 上受支持）或 C++ Microsoft 本机单元测试框架。
3. 项目属性——> 选择为动态库.dll

### 代码覆盖度

代码覆盖率就是运行测试之后，代码被覆盖到了多少，哪些代码跑了，哪些没有跑。根据运行测试手段不同，代码覆盖率分成了单元测试代码覆盖率、接口测试代码覆盖率和功能测试代码覆盖率代码覆盖度是指在测试过程中，实际运行的代码量与全部可运行代码量的比率，它反映了测试用例对代码的覆盖范围，通常以百分比的形式表示，代码覆盖率最终的目的是找到那些没有被覆盖到的代码。

**类型：**

1. **语句覆盖**：语句覆盖是最基本的代码覆盖类型，它衡量的是程序中所有可执行语句是否都被执行过。
2. **分支覆盖**：分支覆盖关注的是程序中所有可能的分支路径是否都被测试过。它不仅要求执行代码，还要求测试代码中的每个分支（如`if`语句、`switch`语句等）都被覆盖。
3. **条件覆盖**：条件覆盖关注的是程序中每个条件表达式的所有可能取值是否都被测试过。它要求每个条件表达式中的每个子条件都被单独测试。
4. **路径覆盖**：径覆盖是最全面的代码覆盖类型，它要求测试程序中所有可能的执行路径。路径是指从程序入口到出口的所有可能的执行序列。

### 运行性能

单元测试在执行过程中表现出的效率和资源消耗情况，运行性能的好坏直接影响开发效率、测试成本以及持续集成的速度。可以从减少测试用例数量、优化测试用例复杂度、减少外部依赖、提高被测试代码的性能、选择合适的测试框架和工具以及并行执行测试等方面入手。

### 测试样例书写

**测试案例**

~~~c++
//MathLib.h
#pragma once
#include<iostream>

class MathUtils
{
public:
	MathUtils();
	~MathUtils();
	//加法
	static int Add(int a, int b);
	//减法
	static int Sub(int a, int b);
	//乘法
	static int Mul(int a, int b);
	//除法
	static float Div(int a, int b);
private:
};
~~~

~~~c++
//MathLib.cpp
#include<iostream>
#include "MathLib.h"

int	MathUtils::Add(int a, int b)
{
	return a + b;
}
int MathUtils::Sub(int a, int b)
{
	return a - b;
}
int MathUtils::Mul(int a, int b)
{
	return a * b;
}
float MathUtils::Div(int a, int b)
{
	if (b == 0)
	{
		std::cout << "被除数不能为0" << std::endl;
		return 0;
	}
	return static_cast<float>(a) / b;
}
~~~

**单元测试(CppUnitTest)**

~~~c++
//MathLibTest
#include "pch.h"
#include "CppUnitTest.h"
#include "../MathLib/MathLib.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace MathLibTest
{
	TEST_CLASS(MathLibTest)
	{
	public:
		//加法测试
		TEST_METHOD(Add_TestMethod)
		{
			Assert::AreEqual(5, MathUtils::Add(2, 3));
			Assert::AreEqual(0, MathUtils::Add(-1, 1));
		}
		//减法测试
		TEST_METHOD(Sub_TestMethod)
		{
			Assert::AreEqual(1, MathUtils::Sub(3, 2));
			Assert::AreEqual(-1, MathUtils::Sub(0, 1));
		}
		//乘法测试
		TEST_METHOD(Mul_TestMethod)
		{
			Assert::AreEqual(250, MathUtils::Mul(2, 125));
			Assert::AreEqual(-2, MathUtils::Mul(2, -1));
		}
		//除法测试
		TEST_METHOD(Div_TestMethod)
		{
			Assert::AreEqual(2.0f, MathUtils::Div(4, 2), 0.00f);
			auto divByZero = [] {MathUtils::Div(1, 0); };
			Assert::ExpectException<std::invalid_argument>(divByZero);

		}
	};
}
~~~



### 单元测试的调试

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%B0%83%E8%AF%95.png)

**单元测试未通过案例**

> 原因：`Div` 方法在除数为0时返回0并打印错误信息，但单元测试期望它 **抛出 `std::invalid_argument` 异常**，导致测试失败。

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9C%AA%E9%80%9A%E8%BF%87%E6%A1%88%E4%BE%8B.png)

~~~c++
//MathLib.cpp（修改代码）
float MathUtils::Div(int a, int b)
{
    if (b == 0)
    {
        throw std::invalid_argument("除数不能为0"); // 抛出异常
    }
    return static_cast<float>(a) / b;
}
~~~

**测试通过案例**

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87%E6%A1%88%E4%BE%8B.png)

**参看函数测试信息**

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%8F%82%E7%9C%8B%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95%E4%BF%A1%E6%81%AF.png)

**单个函数测试**

![](./%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E8%AF%95.png)

