# 库相关知识点

## 静态库

### 静态库的基本概念

静态库（Static Library）是一种在编译时直接嵌入到程序中的库。当编译一个使用静态库的程序时，编译器会将库中你程序所需的所有函数和数据复制到最终的可执行文件中。这意味着，一旦程序被编译，它就包含了所有它需要的库代码，不再需要任何外部的库文件。

### 静态库的生成

<<<<<<< Updated upstream
#### 静态库工程
=======
#### 新建静态库工程
>>>>>>> Stashed changes

1. 点击新建项目，搜索静态库，创建静态库

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA.png)

2. 静态库工程建立后会自动生成头文件和源文件。

![](./%E5%BA%93.assets/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6.png)

3. 编写完成后，点击生成解决方案(**.lib文件**)

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90.png)

#### 已有工程改为静态库

<<<<<<< Updated upstream
在项目属性——> 配置属性——> 常规——> 配置类型（**.lib**）——> 点击生成解决方案。
=======
**在项目属性——> 配置属性——> 常规——> 配置类型（.lib）——> 点击生成解决方案。**
>>>>>>> Stashed changes

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E5%BA%93%E9%85%8D%E7%BD%AE.png)

### 静态库的调用

#### 在工程配置中调用

<<<<<<< Updated upstream
1. 把静态库的工程加到工程中，点击解决方案-添加-现有项目
2. 点击解决方案下的静态库，右键，点击生成依赖项-项目依赖项。

![](./%E5%BA%93.assets/%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96.png)

3. 选择链接器-常规-添加库目录$(OutDir)

![](./%E5%BA%93.assets/%E8%AE%BE%E7%BD%AE%E9%99%84%E5%8A%A0%E7%9B%AE%E5%BD%95.png)

4. 选择链接器-输入-添加依赖项，把生成的静态库添加进去。
=======
1. 右击项目属性，选择**C/C++**的**常规**属性，修改**附加包含目录**，传入**静态库的头文件**。

![](./VisualStudio.assets/%E9%99%84%E5%8A%A0%E5%8C%85%E5%90%AB%E7%9B%AE%E5%BD%95.png)

1. 右击项目属性，选择**C/C++**的**常规**属性，然后配置**附加库目录**（**写入lib所在文件夹地址**）。

![](./VisualStudio.assets/%E9%99%84%E5%8A%A0%E5%BA%93%E7%9B%AE%E5%BD%95.png)

4. 右击项目属性，选择**链接器**的**输入属性**，添加**附加依赖项****，把生成的**静态库名称**添加进去。
>>>>>>> Stashed changes

![](./%E5%BA%93.assets/%E9%99%84%E5%8A%A0%E4%BE%9D%E8%B5%96.png)

#### 在代码中语句加载lib调用

<<<<<<< Updated upstream
1. 在工程源文件中添加头文件**#include“../静态库/头文件.h”**是你自己的静态库的目录；../表示当前文件夹的上级目录，一般你写了../之后会自动弹出可以选择的文件，按照提示选择你需要调用的库函数所在的头文件。

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6.png)

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E5%BA%93%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AF%BC%E5%85%A5.png)

#### 静态库的三种常用导入方式

1. **#pragma comment(…)导入**

![](./%E5%BA%93.assets/%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F%E4%B8%80.png)

1. **在属性中配置附加依赖项**：参考工程配置

2. ### 直接加载到项目工程中（直接将 **lib** 库文件导入到项目工程）

**注意：以上三种方式，只是 lib 库的导入，如果需要使用库的库函数，都是需要导入库的头文件的（#include “Alivendll.h” //静态库头文件）。**
=======
1. 需要先将**静态库中的头文件（.h）**放置到调用库的**可执行文件的同级目录**之中。

2. 然后**#pragma comment(…)**导入lib文件名（可以是相对路径，也可以是绝对路径）。

![](./%E5%BA%93.assets/%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F%E4%B8%80.png)

3. 在**工程源文件（.cpp）**中添加头文件**#include“../静态库/头文件.h”**是静态库的目录。

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E5%BA%93%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AF%BC%E5%85%A5.png)


>>>>>>> Stashed changes

## 动态库

### 动态库的基本概念

**动态库（Dynamic Library）**，也称为**共享库（Shared Library）**，是一种在程序运行时（而非编译时）加载的代码库。与静态库不同，动态库不会被直接嵌入到可执行文件中，而是在程序启动或运行时动态加载到内存中，供多个程序共享使用，**(.dll)**。

### 动态库的生成

#### 通过导出语句生成

~~~c++
__declspec(dllexport)，此修饰符告诉编译器和链接器被它修饰的函数或变量需要从DLL导出，以供其他应用程序使用；
与__declspec(dllexport)相对的还有一句代码是__declspec(dllimport),此修饰符的作用是告诉编译器和链接器被它修饰的函数或变量需要从DLL导入。
~~~

![](./%E5%BA%93.assets/%E4%BB%A3%E7%A0%81%E5%AF%BC%E5%87%BA.png)

#### 通过模块文件生成

1. 工程新建——>代码——>.def文件

   ![](./%E5%BA%93.assets/def%E6%96%87%E4%BB%B6.png)

2. 工程配置

   ![](./%E5%BA%93.assets/%E9%85%8D%E7%BD%AE.png)

   ![](./%E5%BA%93.assets/%E9%93%BE%E6%8E%A5.png)

3. 编写.def文件

   ![](./%E5%BA%93.assets/def%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83.png)

4. 点击工程右键生成解决方案

   ![](./%E5%BA%93.assets/%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90.png)

### 动态库的调用

#### 在工程配置中调用

1. 在测试项目中新建**inlcude、lib、dll**文件夹

2. 然后分别将动态库生成的**.h、.lib、.dll**文件放入到相应的文件夹中

   ![](./%E5%BA%93.assets/%E6%96%87%E4%BB%B6%E5%A4%B9.png)

3. 工程配置

   1. include头文件包含路径

      ![](./%E5%BA%93.assets/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84.png)

   2. lib文件夹包含路径

      ![](./%E5%BA%93.assets/lib%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84.png)

   3. lib准确路径配置

      ![](./%E5%BA%93.assets/lib%E5%87%86%E7%A1%AE%E8%B7%AF%E5%BE%84.png)

   4. 完成基本工程配置

<<<<<<< Updated upstream
#### 在代码中语句加载lib调用

=======
>>>>>>> Stashed changes
1. **依赖工程配置中的头文件、lib以及dll文件，缺一不可**。（主要运用于编译阶段）
2. 隐式调用，适合标准场所使用，调用简单。

![](./%E5%BA%93.assets/%E9%9D%99%E6%80%81%E8%B0%83%E7%94%A8.png)

<<<<<<< Updated upstream
=======
#### 在代码中语句加载lib调用

**参考静态库的代码lib调用**

1. 需要将**动态库**生成的**lib文件目录**配置到**链接器**的**附加库目录**上

![](./%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E5%BA%93lib%E8%B0%83%E7%94%A8.png)

2. 在**链接器**中的**附加依赖项**配置**动态库生成的lib文件名称**。

![](./%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E5%BA%93lib%E8%B0%83%E7%94%A81.png)

3. **#pragma comment(…)**导入**lib文件名**。

![](./%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E5%BA%93%E8%B0%83%E7%94%A8lib.png)

>>>>>>> Stashed changes
#### 在代码中语句加载dll调用

1. **显式调用通过 `LoadLibrary` 和 `GetProcAddress` 动态加载DLL，无需链接 `.lib` 文件，但该方式对生成的dll的规范有一定的要求否则容易出错。**
2. **适合灵活场景（如插件），需手动加载，无编译依赖。**

~~~c++
// 定义函数指针类型（用于后面的函数调用）
typedef int (*AddFunc)(int, int);  

//LoadLibrary是用来加载dll的(调用成功则返回函数地址，否则返回0或NULL。)
	//1. 路径（程序与dll要放在同一文件夹），需要将DLL与exe放于同一目录
	//2. dll本身错误（依赖其他dll）
HMODULE hDll = LoadLibrary(L"Test01.dll");

//GetProcAddress()是用来获取函数地址的（当其调用出错时，用GetLastError()得到返回值一般为127，表示函数地址获取失败。）
AddFunc add = (AddFunc)GetProcAddress(hDll, "plus_int");

//FreeLibrary()是用来释放加载dll时占用的空间的，由于Loadlibrary()为对dll的显式加载（又叫动态加载），这种方式不会在用完dll后自动清理dll所占用的空间，所以我们要手动清除dll所占用的空间。否则会导致内存泄漏。
FreeLibrary(hdll);
~~~

![](./%E5%BA%93.assets/%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8.png)